// ----------------------------------------------------------------------------// [Simme]//       Java Source File: SendableUI.java//                  $Date: 2004/09/13 15:26:53 $//              $Revision: 1.9 $// ----------------------------------------------------------------------------package at.einspiel.messaging;import java.io.IOException;import at.einspiel.logging.Logger;import at.einspiel.simme.client.ui.IDynamicUI;import at.einspiel.simme.nanoxml.XMLElement;import at.einspiel.simme.nanoxml.XMLParseException;/** * This class represents an easily createable and sendable user interface. It * provides two possibilities for creation: * <ul> * <li>The <code>SendableUI</code> may be initialized with an xml string, by * calling the method {@linkplain #initialize(String)}. See its doc for further * information. Alternatively this string may be passed as a parameter to the * constructor.</li> * <li>The second possibility is provided by means of * {@linkplain #SendableUI(String, String)}which creates a simple instance with * only title and text message.</li> * </ul> * <p> * The xml string to create a new instance of SendableUI is directly accessible * through {@linkplain #getXmlString()}. * </p> *  * @author kariem */public class SendableUI {	private String commPath;	private String tmpPath;	private ISimpleInfo infoObject;	private IDynamicUI dynamicUI;	/**	 * Creates a new <code>SendableUI</code> from a string.	 * 	 * @param xmlString	 *            a string that contains information for the building a	 *            displayable component.	 * @see #initialize(String)	 */	public SendableUI(String xmlString) {		initialize(xmlString);	}	/**	 * Creates a new instance of <code>SendableUI</code>.	 * 	 * @param title	 *            the title.	 * @param message	 *            the message.	 */	public SendableUI(String title, String message) {		infoObject = new InfoText(title, message);	}	/**	 * Initializes the SendableUI with the given xml string.	 * 	 * @param xmlString	 *            should be in the format.	 * 	 * <pre>	 *      &lt;element title=&quot;title&quot; id=&quot;ID&quot; list=&quot;true&quot;&gt;	 *          &lt;child&gt;content 1&lt;/child&gt;	 *          &lt;child&gt;content 2&lt;/child&gt;	 *          &lt;child&gt;content 3&lt;/child&gt;	 *      &lt;/element&gt;	 * </pre>	 * 	 * or	 * 	 * <pre>	 *      &lt;element title=&quot;title&quot;	 *               id=&quot;ID&quot;	 *               list=&quot;false&quot;	 *               msg=&quot;Text&quot;/&gt;	 * </pre>	 */	public void initialize(String xmlString) {		XMLElement xml = new XMLElement();		try {			xml.parseString(xmlString);			makeXmlDisplayable(xml);		} catch (XMLParseException xex) {			// no xml information: create info text object			infoObject = new InfoText(xmlString, xex);		}	}	/**	 * Returns the information object.	 * 	 * @return the info object.	 *  	 */	public ISimpleInfo getInfoObject() {		return infoObject;	}	/**	 * Whether this instance builds a list.	 * 	 * @return <code>true</code> if this instance may be rendered into a list,	 *         <code>false</code> otherwise.	 */	public boolean isList() {		return infoObject.isList();	}	/**	 * Whether this instance has associated meta-information. This could be	 * whatever designed.	 * 	 * @return <code>true</code> if there is meta-info associated,	 *         <code>false</code> otherwise.	 */	public boolean hasMetaInfo() {		return infoObject.hasMetaInfo();	}	/**	 * Creates a displayable from an xml element. The element must contain the	 * attributes <code>title</code> and <code>id</code>. The boolean	 * attribute <code>list</code> is optional. If set to <code>true</code>	 * the created displayable will show a list with several entries.	 * 	 * @param xml	 *            the element.	 */	private void makeXmlDisplayable(XMLElement xml) {		final String name = xml.getName();		// show either list, or simple status message		if (xml.getAttributeBoolean(ISimpleInfo.ATTR_LIST)) {			infoObject = new InfoList(xml);		} else if (name.equals(ISimpleInfo.TAG_TEXT)) {			infoObject = new InfoText(xml);		} else { // special information, save first child			infoObject = new InfoXml(xml);		}		// see if autoupdate is contained within xml information		int update = xml.getAttributeInt(ISimpleInfo.ATTR_UPDATE);		if (update > 0) {			// automatic update in seconds specified by ATTR_UPDATE			// see if another path was specified.			String updatePath = xml.getAttribute(ISimpleInfo.ATTR_UPDATE_PATH);			if (updatePath != null) {				this.tmpPath = updatePath;			}			// start new update thread			UpdateThread t = new UpdateThread(update);			t.start();		}	}	/**	 * Returns an XML representation of this object as a string. This string can	 * be used to create a new sendable UI, by using {@link #SendableUI(String)}.	 * This method may be used to send user interface information across a	 * network. The object is serialized to XML.	 * 	 * @return a string that contains the information to render the user	 *         interface component.	 */	public String getXmlString() {		return infoObject.getXmlString();	}	/**	 * Updates the sendable ui from the main communication path.	 * @see #update(Request)	 */	public void update() {		update(new Request());	}	/**	 * <p>	 * Immediately connects to the server and updates the user interface. The	 * connection is made to the path specified in the field <i>commPath </i>,	 * accessible via corresponding methods ({@linkplain #setCommPath(String)},	 * {@linkplain #getCommPath()}).	 * </p>	 * <p>	 * If a temporary path was specified, it will override the <i>commPath </i>	 * field for this update. After this update, the temporary path will be	 * reset to <code>null</code>.	 * </p>	 * 	 * @param r	 *            the request to be used with some additional attributes set.	 * @see #update()	 */	public void update(Request r) {		r.addUserData();		// attach id of menu if possible		if (infoObject != null) {			r.setParam(IConstants.PARAM_MENUID, Integer.toString(infoObject.getId()));		}				final String path;		if (tmpPath != null) {			path = tmpPath;			// reset temp path			tmpPath = null;		} else {			path = commPath;		}		// connect to specified path		r.sendRequest(path);		try {			String response = new String(r.getResponse());			// reset parameters			r.reset();			initialize(response);		} catch (IOException e) {			// error occured			initialize("Verbindung wurde unterbrochen: " + e.getMessage());			e.printStackTrace();		}		informUI();	}	/** Informs the user interface of changes. */	private void informUI() {		if (dynamicUI != null) {			dynamicUI.updateDisplay();		}	}	/**	 * Returns the dynamic user interface instance.	 * @return Returns the dynamicUI or <code>null</code> if none has been	 *         set.	 */	public IDynamicUI getDynamicUI() {		return dynamicUI;	}	/**	 * Sets the dynamic user interface field of this object.	 * @param dynamicUI	 *            The dynamicUI to set.	 */	public void setDynamicUI(IDynamicUI dynamicUI) {		this.dynamicUI = dynamicUI;	}	/**	 * Returns the path which is used for communication.	 * @return the communications path.	 */	public String getCommPath() {		return commPath;	}	/**	 * Sets the communication path	 * @param path	 *            the path to communicate with the server.	 */	public void setCommPath(String path) {		this.commPath = path;	}	/**	 * This class helps updating the user interface after a specified amount of	 * seconds.	 */	class UpdateThread extends Thread {		private final int seconds;		/**		 * Creates a new instance of <code>UpdateThread</code>.		 * @param updateTime		 *            the time to update the user interface in seconds.		 */		public UpdateThread(int updateTime) {			this.seconds = updateTime;		}		/** @see java.lang.Thread#run() */		public void run() {			try {				// sleep the time specified by seconds				//Logger.debug(getClass(), "sleeping for " + seconds + " seconds and waiting for update.");				sleep(seconds * 1000);			} catch (InterruptedException e) {				Logger.error("Error while waiting for update", e);			}			// retrieve updated information and update UI accordingly			update();		}	}}